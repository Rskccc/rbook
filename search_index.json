[["index.html", "R for Cancer Research", " R for Cancer Research SKCCC R Group 2020-11-05 "],["final-project.html", "Chapter 1 Final Project 1.1 What is it? 1.2 What are the project options? 1.3 What needs to be in the report? 1.4 How should the report be formatted? 1.5 Recommendations", " Chapter 1 Final Project 1.1 What is it? In this class, you are expected to formulate groups with your classmates, work as a group on a data analysis project using what you learn from the class (and beyond) about R, generate a analysis report, and present as a group your report in the last week. 1.2 What are the project options? Ideally, the projects will be based on real tasks you have from your research or daily work. Several options will also be suggested to you only if your group has difficulty identifying an appropriate topic. 1.3 What needs to be in the report? The report should consider including the following sections: Background Introduction of the project Goal Research question(s) the analysis aims to answer Data Description of the data Data cleaning and manipulation steps Data summary and visualization Analysis Methods applied in the analysis Results and summary Report your findings 1.4 How should the report be formatted? Use R Markdown for conducting your analysis and generating the report. You report may be included in this R for Cancer Research book! An example is provided in the next chapter 1.5 Recommendations Try things out in R You should make a real effort to practice what was covered in class in a complete project that includes reading in data, doing something intentional to it and reporting the results of that analysis in an organized way. Write up your methods and results In addition to your code, the report should also be a well-written document that clearly summarizes the analysis, and presents results in a logical and readable way. Plots should have meaningful labels, and should incorporate such elements as color, multiple plotting symbols, and legends as necessary for clarity. Summary statistics should be rounded to a relevant number of significant digits, etc… Submit clean, well commented code Code should employ self-documenting variable names, and include comments as needed so that a collaborator could follow it easily. Reproducibility This means that we, with the same files in an appropriately named directory, can reproduce your final results simply by rendering your R markdown file. You will find it easier to produce clean code if you designate a discrete work space for the project, and keep everything there, always work from a script you write rather than working interactively at the R-prompt, organize your code into logical sections, and annotate your code with comments so you can keep track of what each chunk is supposed to do. "],["movie.html", "Chapter 2 The Movie Lens Data (Example) 2.1 Background 2.2 Goal 2.3 Data 2.4 Analysis 2.5 Results and summary", " Chapter 2 The Movie Lens Data (Example) 2.1 Background MovieLens (http://grouplens.org/datasets/movielens/) is a movie recommendation engine devel- oped and administered by a research group at the University of Minnesota. It is very much like the ones included in Netflix and elsewhere, but free and open. The latest release of the data includes 20,000,000 individual ratings of 27,000 movies by 138,000 users. For class, we are using (most of) the much smaller, 1998 release, which includes 100,000 ratings, of 1700 movies by nearly 1000 users. The data included on the class website is modified slightly from the original. Specifically, we have: added informative column names, which were not included in the original data files, but described in a separate readme file removed a couple of columns, including a timestamp indicating when the rating was made changed | delimited files to tab delimited, removed 2 movies of unknown genre, removed duplicate entries for a handful of movies that are included in the database twice. It should be noted that some movie names are duplicated, when two different films happen to have the same name, or when a movie is remade at a later date. Name and year together make a unique identifier in these cases. There are 4 data files in the course folder: The ratings themselves are found in ratingsData.txt, one rating per line. Users and movies are labeled by random, numerical IDs in the ratings data. A separate movieData.txt file links the numerical movieID to title, year, and genre. The userData.txt file provides basic demographics for each user, including age, gender, occupation and 1zipcode. A fourth file ratingsDataPlus.txt combining limited information from all 3 files is provided as well for your convenience. 2.2 Goal To break the ratings for each movie down by user characteristics. 2.3 Data The first step will be to read in the data. userDat &lt;- read.table(&quot;Data/userData.txt&quot;, header = T, row.names = 1, as.is = T, sep = &quot;\\t&quot;, fill = T) movieDat &lt;- read.table(&quot;Data/movieData.txt&quot;, header = T, row.names = 1, as.is = T, sep = &quot;\\t&quot;, quote = &quot;&quot;) ratingsDat &lt;- read.table(&quot;Data/ratingsData.txt&quot;, header = T, as.is = T, sep = &quot;\\t&quot;) After reading all 3 files into R, you will want to think about how you organize and store the data for analysis. Do your data objects all have useful row and column names so that you can easily map movies and users across all data sets? Do you like having the ratings data in a 3 column format, would a matrix make more sense? Are you happy having everything in 3 separate files? The format used in the ratingsDataPlus.txt file, may make it easier to work with the data for some problems. There are trade-offs no matter how its done, though, combining the files may make it easier to write code for analyses, but it uses a lot of storage space - the ratingsPlus file alone is more than 3 times as large as the other 3 files combined. Logically, data organization comes before analysis, but its not always possible to anticipate your needs in advance, so you are likely to add things to this section as you go. ## make a matrix of ratings ## maybe it will be helpful to have a simple list of movie ids mov &lt;- rownames(movieDat) ## and a simple list of user ids usr &lt;- rownames(userDat) ## start with all na&#39;s in the matrix ratMat &lt;- matrix(rep(NA, length(mov) * length(usr)), nrow=length(mov)) # ## add row and col names rownames(ratMat) &lt;- mov colnames(ratMat) &lt;- usr ## and fill it up with ratings for (i in 1:dim(ratingsDat)[1]) { n_r &lt;- as.character(ratingsDat[i,2]) n_c &lt;- as.character(ratingsDat[i,1]) ratMat[n_r, n_c] &lt;- ratingsDat[i,3] } ## here is a list of all possible genre names genres &lt;- colnames(movieDat)[7:20] The age data is numerical, but it might be useful to divide it into groups for some applications. First I looked at a summary of ages summary(userDat$age) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 7.00 25.00 31.00 34.05 43.00 73.00 It is decided that &lt;25, 25-35, 35 - 45 and 45-75 would produce reasonably large age groups. ageGp &lt;- rep(75, dim(userDat)[1]) ageGp[userDat$age&lt;=45] &lt;- 45 ageGp[userDat$age&lt;=35] &lt;- 35 ageGp[userDat$age&lt;=25] &lt;- 25 summary(ageGp) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 25.0 25.0 35.0 42.1 45.0 75.0 2.4 Analysis There are lots of different things we can do here. Here is a function that takes a movie name as argument and plots age on the x-axis vs ratings on the y-axis. Color is used to specify gender. ### put in the movieID as argument ratingsPlot &lt;- function(movID, genderCol = c(&quot;M&quot; = &quot;yellow&quot;, &quot;F&quot; = &quot;blue&quot;)) { ## get the real movie name name &lt;- movieDat[movID,&quot;name&quot;] ## get the list of users who rated that movie raters &lt;- colnames(ratMat)[!is.na(ratMat[movID,])] plot(userDat[raters,&quot;age&quot;], ### need ages for those users ratMat[movID,raters], ### need ratings for those users pch = 16, col = genderCol[userDat[raters,&quot;gender&quot;]], ### need gender main = name, xlab = &quot;age&quot;, ylab = &quot;rating&quot;) } ratingsPlot(rownames(ratMat)[1]) ratingsPlot(mov[2]) 2.5 Results and summary Most viewers of Golden Eye were males, whereas gender distribution of Toy Story was more balanced between males and females. The viewers of Toy Story were younger in generate compared to “Golden Eye”. There is not a clear trend between ratings and age observed in neither of the two movies. "],["project-options.html", "Chapter 3 Project Options 3.1 The Movie Lens Data (Example) 3.2 Todd Golub’s Study", " Chapter 3 Project Options 3.1 The Movie Lens Data (Example) Consider the movie example in the previous chapter and try to answer the following questions: Organizing After reading all 3 files into R, you will want to think about how you organize and store the data for analysis. Do your data objects all have useful row and column names so that you can easily map movies and users across all data sets? Do you like having the ratings data in a 3 column format, would a matrix make more sense? Are you happy having everything in 3 separate files? The format used in the ratingsDataPlus.txt file, may make it easier to work with the data for some problems. There are trade-offs no matter how its done, though, combining the files may make it easier to write code for analyses, but it uses a lot of storage space - the ratingsPlus file alone is more than 3 times as large as the other 3 files combined. Favorite Genre Write code to identify a user’s favorite/least favorite genre, based on ratings. Use loops or apply functions to apply your code to all users, and then determine if results differ by age or gender. Note that genres are not mutually exclusive, this may affect your analysis. User Similarity To make personalized recommendations, movie recommendation engines start by matching each user to others in the database with similar taste. Come up with a scheme for measuring similarity of users and code it up. Calculate a matrix of similarity scores for all pairs of users. We can build on this code on the second lab to make user recommendations. Who liked Star Wars? Having matched a new user to a similar cohort from the database, the recommendation engine has to use the cohort’s past ratings to predict which movies the new user will like. It should not be surprising that Star Wars’ with 583 ratings, is the most watched movie in the database. Not everyone liked it though, write code to predict whether a user will like Star Wars, and apply it to all users. Apply the same approach to both Return of the Jedi and another, non-Star Wars movie, like George of the Jungle. Which predictions are closest to those for Star Wars? 3.2 Todd Golub’s Study Background In 1999, Todd Golub and collaborators at the Whitehead Institute published this paper in Science. Molecular Classification of Cancer: Class Discovery and Class Prediction by Gene Expression Monitoring T. R. Golub, et al. Science 286, 531 (1999); DOI: 10.1126/sci- ence.286.5439.531. This study has become one of the milestones in the history of gene expression microarrays, instrumental in establishing that microarray arrays are reliable enough to be used for such complex tasks as tumor class discovery, and prediction. The accompanying data files contain a slightly modified version of the original study data. We have reduced the number of genes to speed up computation, and removed redundant probes so that each gene is only measured once. We have also messed with the original sample names so that the project can include the kinds of data grooming tasks that research datasets often require before they can be analyzed. Goal Among the gene specific results reported in the Science paper, were findings that Cyclin D3 (CCND3) was more expressed in ALL whereas CD33 was more highly expressed in AML? Identify these genes in the expression data and try to verify the finding by performing t-tests on them. This will require getting the AML-ALL designations from the clinical data file. "],["references.html", "References", " References "]]
